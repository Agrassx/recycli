![recycli_logo](https://user-images.githubusercontent.com/1109620/115422301-7405b780-a205-11eb-9372-1411ff17168d.png)

Recycli is a Kotlin library for Android RecyclerView that simplifies complex multiple view types lists creation. With DiffUtils inside, annotation based adapter generator and MVI pattern as philosophy it provides both simple and powerful tool for fast RecyclerView based screens development.

![ezgif-6-e9d7bd416187](https://user-images.githubusercontent.com/1109620/115579256-a7f8df80-a2ce-11eb-9bc2-ac79d3905b89.gif)

## Table of Contents  
[Installation](#installation)  
[First steps](#first_steps)  
[Use Views or ViewHolders](#view_holders)  
[Reaction on clicks and state changes](#clicks_and_state)  
[Sealed classes as states](#sealed)  
[Sealed classes and binding functions](#sealed_binfing)  
[One item state and several views](#one_several)  
[Horizontal sub lists](#horizontal)  
[Multi-module applications](#multi_module)  
[License](#license)  

<a name="installation"/>

## Installation
Add Maven Central to you repositories at project or module level build.gradle:

```gradle
allprojects {
    repositories {
        mavenCentral()
    }
}
```
and add Kapt plugin and Recycli dependencies to your build.gradle at module level:
```gradle
plugins {
    id 'kotlin-kapt'
}

dependencies {
    implementation 'com.detmir.recycli:adapters:1.0.4'
    compileOnly 'com.detmir.recycli:annotations:1.0.4'
    kapt 'com.detmir.recycli:processors:1.0.4'
}

```

<a name="first_steps"/>

## First steps
First create Kotlin data classes annotated with `@RecyclerItemState` and extends `RecyclerItem`. Unique (for this adapter) String `id` must be provided.
Those classes describes recycler items states. Let's create 2 data classes - Header and User items.
```java
@RecyclerItemState
data class HeaderItem(
    val id: String,
    val title: String
) : RecyclerItem {
    override fun provideId() = id
}
```

```java
@RecyclerItemState
data class UserItem(
    val id: String,
    val firstName: String
) : RecyclerItem {
    override fun provideId() = id
}
```

And add two view classes `HeaderItemView` and `UserItemView` that extends any `View` or `ViewGroup` container. Annotate those classes with `@RecyclerItemView` annotation. Also add method with recycler item state as parameter and annotate it with `@RecyclerItemStateBinder`.

```java
@RecyclerItemView
class HeaderItemView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : FrameLayout(context, attrs, defStyleAttr) {

    private val title: TextView

    init {
        LayoutInflater.from(context).inflate(R.layout.header_view, this)
        title = findViewById(R.id.header_view_title)
    }

    @RecyclerItemStateBinder
    fun bindState(headerItem: HeaderItem) {
        title.text = headerItem.title
    }
}
```

```java
@RecyclerItemView
class UserItemView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : FrameLayout(context, attrs, defStyleAttr) {

    private val firstName: TextView

    init {
        LayoutInflater.from(context).inflate(R.layout.user_view, this)
        firstName = findViewById(R.id.user_view_first_name)
    }

    @RecyclerItemStateBinder
    fun bindState(userItem: UserItem) {
        firstName.text = userItem.firstName
    }
}
```

Those views will be used at `onCreateViewHolder` functions at `RecyclerView.Adapter` for corresponding states. `bindState` will be called when `onBindViewHolder` called at adapter.

And now you can create `RecyclerView`, set `RecyclerAdapter` as adapter and bind list of `RecyclerItems` to it.
Note that RecyclerBinderImpl is passed as parameter to RecyclerAdapter - this class is generated by Recycli lib usig the annotations mentioned earlier. If the class doesn't exist yet, simply click *Build/Make Project* at *Android studio*.

```java
class DemoActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val recyclerView = findViewById<RecyclerView>(R.id.activity_case_0100_recycler)
        recyclerView.layoutManager = LinearLayoutManager(this)
        val recyclerAdapter = RecyclerAdapter(setOf(RecyclerBinderImpl()))
        recyclerView.adapter = recyclerAdapter

        recyclerAdapter.bindState(
            listOf(
                HeaderItem(
                    id = "HEADER_USERS",
                    title = "Users"
                ),
                UserItem(
                    id = "USER_ANDREW",
                    firstName = "Andrew",
                    online = true
                ),
                UserItem(
                    id = "USER_MAX",
                    firstName = "Max",
                    online = true
                )
            )
        )
    }
} 
```
And `RecyclerView` will display:

![Screenshot_20210423-151457_KKppt3](https://user-images.githubusercontent.com/1109620/115869752-03e67400-a447-11eb-9d63-0c78e98bb4f7.png)

[Demo Activity](https://github.com/detmir/recycli/blob/master/app/src/main/java/com/detmir/kkppt3/Case0100SimpleActivity.kt)



<a name="view_holders"/>

## Use Views or ViewHolders

In the example earlier we used classes that extends `ViewGroup` or `View` to provide `RecyclerView` with the corresponding view. In case of you prefer inflate views directly in `RecyclerView.ViewHolder` your can do it with `@RecyclerItemViewHolder` and `@RecyclerItemViewHolderCreator` annotations. Note that `@RecyclerItemViewHolderCreator` must be a function located in companion class of `ViewHolder` See the complete example below.

Recycler item state:

```java
@RecyclerItemState
data class ServerItem(
    val id: String,
    val serverAddress: String
) : RecyclerItem {
    override fun provideId() = id
}
```

View holder that can bind `ServerItem` state:

```java
@RecyclerItemViewHolder
class ServerItemViewHolder(view: View) : RecyclerView.ViewHolder(view) {
    private val serverAddress: TextView = view.findViewById(R.id.server_item_title)

    @RecyclerItemStateBinder
    fun bindState(serverItem: ServerItem) {
        serverAddress.text = serverItem.serverAddress
    }

    companion object {
        @RecyclerItemViewHolderCreator
        fun provideViewHolder(context: Context): ServerItemViewHolder {
            val view = LayoutInflater.from(context).inflate(R.layout.server_item_view, null)
            return ServerItemViewHolder(view)
        }
    }
}
```

Bind items to `RecyclerView`:

```java
class Case0101SimpleVHActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val recyclerView = findViewById<RecyclerView>(R.id.activity_case_0101_recycler)
        recyclerView.layoutManager = LinearLayoutManager(this)
        val recyclerAdapter = RecyclerAdapter(setOf(RecyclerBinderImpl()))
        recyclerView.adapter = recyclerAdapter

        recyclerAdapter.bindState(
            listOf(
                HeaderItem(
                    id = "HEADER_SERVERS",
                    title = "Servers"
                ),
                ServerItem(
                    id = "SERVER1",
                    serverAddress = "124.45.22.12"
                ),
                ServerItem(
                    id = "SERVER2",
                    serverAddress = "90.0.0.28"
                )
            )
        )
    }
}
```

the result:

![Screenshot_20210423-150530_KKppt3](https://user-images.githubusercontent.com/1109620/115868740-938b2300-a445-11eb-850e-8404e52dab90.png)

[Demo Activity](https://github.com/detmir/recycli/blob/master/app/src/main/java/com/detmir/kkppt3/Case0101SimpleVHActivity.kt)


<a name="clicks_and_state"/>

## Reaction on clicks and state changes

Click reaction is handled in MVI manner. Recycler item provides intent via its state function invocation. ViewModel handles the intent, recalculates the state and binds it to adapter. 

Firstly provide recycler item state with click reaction functions:

```java
@RecyclerItemState
data class UserItem(
    val id: String,
    val firstName: String,
    val onCardClick: (String) -> Unit,
    val onMoveToOnline: (String) -> Unit,
    val onMoveToOffline: (String) -> Unit
) : RecyclerItem {
    override fun provideId() = id
}
```

Add on click listeners at view:

```java
@RecyclerItemView
class UserItemView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : FrameLayout(context, attrs, defStyleAttr) {

    private lateinit var userItem: UserItem

    init {
        ...        
        toOnlineButton.setOnClickListener {
            userItem.onMoveToOnline.invoke(userItem.firstName)
        }

        toOfflineButton.setOnClickListener {
            userItem.onMoveToOffline.invoke(userItem.firstName)
        }

        holder.setOnClickListener {
            userItem.onCardClick.invoke(userItem.firstName)
        }
    }

    @RecyclerItemStateBinder
    fun bindState(userItem: UserItem) {
        this.userItem = userItem
        firstName.text = userItem.firstName
    }
}
```

At you ViewModel handle the clicks and recreate state if needed:

```java
lateinit var recyclerAdapter: RecyclerAdapter
private val onlineUserNames = mutableListOf("James","Mary","Robert","Patricia")
private val offlineUserNames = mutableListOf("Michael","Linda","William","Elizabeth","David")

private fun updateRecycler() {
        val recyclerItems = mutableListOf<RecyclerItem>()

        recyclerItems.add(
            HeaderItem(
                id = "HEADER_ONLINE_OPERATORS",
                title = "Online operators ${onlineUserNames.size}"
            )
        )

        onlineUserNames.forEach { name ->
            recyclerItems.add(
                UserItem(
                    id = name,
                    firstName = name,
                    online = true,
                    onCardClick = ::cardClicked,
                    onMoveToOffline = ::moveToOffline
                )
            )
        }

        recyclerItems.add(
            HeaderItem(
                id = "HEADER_OFFLINE_OPERATORS",
                title = "Offline operators ${offlineUserNames.size}"
            )
        )

        offlineUserNames.forEach {
            recyclerItems.add(
                UserItem(
                    id = it,
                    firstName = it,
                    online = false,
                    onCardClick = ::cardClicked,
                    onMoveToOnline = ::moveToOnline
                )
            )
        }

        recyclerAdapter.bindState(recyclerItems)
    }

    private fun cardClicked(name: String) {
        Toast.makeText(this, name, Toast.LENGTH_SHORT).show()
    }

    private fun moveToOffline(name: String) {
        onlineUserNames.remove(name)
        offlineUserNames.add(0, name)
        updateRecycler()
    }

    private fun moveToOnline(name: String) {
        offlineUserNames.remove(name)
        onlineUserNames.add(name)
        updateRecycler()
    }
```

Note, we do all logic inside Activity for simplification purposes

![ezgif-6-a9ba26ee168f](https://user-images.githubusercontent.com/1109620/115968128-e0065980-a53e-11eb-9b9e-e0049272edc3.gif)

[Demo Activity](https://github.com/detmir/recycli/blob/master/app/src/main/java/com/detmir/kkppt3/Case0200ClickAndStateActivity.kt)


<a name="sealed"/>

## Sealed classes as states

Its common to use sealed classes as UI states. You can create sealed class state items and bind it easily.

Create sealed class:

```java
@RecyclerItemState
sealed class ProjectItem : RecyclerItem {
    abstract val id: String
    abstract val title: String

    data class Failed(
        override val id: String,
        override val title: String,
        val why: String
    ) : ProjectItem()

    data class New(
        override val id: String,
        override val title: String
    ) : ProjectItem()

    sealed class Done: ProjectItem() {
        data class BeforeDeadline(
            override val id: String,
            override val title: String
        ) : Done()

        data class AfterDeadline(
            override val id: String,
            override val title: String,
            val why: String
        ) : Done()
    }

    override fun provideId() = id
}
```

Use Kotlin `when` to handle different sealed class states:

```java
@RecyclerItemView
class ProjectItemView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : FrameLayout(context, attrs, defStyleAttr) {

    @RecyclerItemStateBinder
    fun bindState(projectItem: ProjectItem) {
        projectTitle.text = projectItem.title
        when (projectItem) {
            is ProjectItem.Failed -> projectDescription.text = "Failed"
            is ProjectItem.New -> projectDescription.text = "New"
            is ProjectItem.Done.AfterDeadline -> projectDescription.text = "After deadline"
            is ProjectItem.Done.BeforeDeadline -> projectDescription.text = "Before deadline"
        }
    }
}
```

Create and bind recycler state:

```java
recyclerAdapter.bindState(
            listOf(
                ProjectItem.Failed(
                    id = "FAILED",
                    title = "Failed project",
                    why = ""
                ),
                ProjectItem.New(
                    id = "NEW",
                    title = "New project"
                ),
                ProjectItem.Done.BeforeDeadline(
                    id = "BEFORE_DEAD_LINE",
                    title = "Done before deadline project"
                ),
                ProjectItem.Done.AfterDeadline(
                    id = "AFTER_DEAD_LINE",
                    title = "Done after deadline project",
                    why = ""
                )
            )
        )
```



![Screenshot_20210423-170301_KKppt3](https://user-images.githubusercontent.com/1109620/115882923-e967c700-a455-11eb-8bcc-3990b9a740fb.png)

[Demo Activity](https://github.com/detmir/recycli/blob/master/app/src/main/java/com/detmir/kkppt3/Case0300Sealed.kt)


<a name="sealed_binfing"/>

## Sealed classes and binding functions

You can create binding functions for every sub class of sealed state (or even for sealed sub classes of sealed class):

Sealed class recyceler item state:

```java
@RecyclerItemState
sealed class PipeLineItem : RecyclerItem {
    data class Input(
        val id: String,
        val from: String
    ) : PipeLineItem() {
        override fun provideId() = id
    }

    data class Output(
        val id: String,
        val to: String
    ) : PipeLineItem() {
        override fun provideId() = id
    }
}
```

```java
@RecyclerItemView
class PipeLineItemView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : FrameLayout(context, attrs, defStyleAttr) {
    ... 
    @RecyclerItemStateBinder
    fun bindState(input: PipeLineItem.Input) {
        destination.text = input.from
    }


    @RecyclerItemStateBinder
    fun bindState(output: PipeLineItem.Output) {
        destination.text = output.to
    }
}
```

[Demo Activity](https://github.com/detmir/recycli/blob/master/app/src/main/java/com/detmir/kkppt3/Case0301SealedSeveralBinds.kt)



<a name="one_several"/>

## One item state and several views

Sometimes we need several view variants for one recycler item state class. You can define which view to use by overriding `withView()` method of `RecyclerItem`

```java
@RecyclerItemState
data class CloudItem(
    val id: String,
    val serverName: String,
    val intoView: Class<out Any>
) : RecyclerItem {
    override fun provideId() = id
    override fun withView() = intoView
}
```

Create several views or view holders that can bind CloudItem:

```java
@RecyclerItemView
class CloudAzureItemView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : FrameLayout(context, attrs, defStyleAttr) {
    ....
    @RecyclerItemStateBinder
    fun bindState(cloudItem: CloudItem) {
        name.text = cloudItem.serverName
    }
}
```

```java
@RecyclerItemView
class CloudAmazonItemView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : FrameLayout(context, attrs, defStyleAttr) {
    ....
    @RecyclerItemStateBinder
    fun bindState(cloudItem: CloudItem) {
        name.text = cloudItem.serverName
    }
}
```

```java
@RecyclerItemViewHolder
class DigitalOceanViewHolder(view: View) : RecyclerView.ViewHolder(view) {
    @RecyclerItemStateBinder
    fun bindState(cloudItem: CloudItem) {
        name.text = cloudItem.serverName
    }

    companion object {
        @RecyclerItemViewHolderCreator
        fun provideViewHolder(context: Context): DigitalOceanViewHolder {
            return DigitalOceanViewHolder(LayoutInflater.from(context).inflate(R.layout.cloud_digital_ocean_item_view, null))
        }
    }
}
```

And fill adapter with items:

```java
class DemoActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        ....
        recyclerAdapter.bindState(
            listOf(
                CloudItem(
                    id = "GOOGLE",
                    serverName = "Google server",
                    intoView = CloudGoogleItemView::class.java
                ),
                CloudItem(
                    id = "AMAZON",
                    serverName = "Amazon server",
                    intoView = CloudAmazonItemView::class.java
                ),
                CloudItem(
                    id = "AZURE",
                    serverName = "Azure server",
                    intoView = CloudAzureItemView::class.java
                ),
                CloudItem(
                    id = "DIGITAL_OCEAN",
                    serverName = "Digital ocean server",
                    intoView = DigitalOceanViewHolder::class.java
                )
            )
        )
    }
}
```

![Screenshot_20210424-214134_KKppt3](https://user-images.githubusercontent.com/1109620/115969528-02e83c00-a546-11eb-8787-43918cf84a69.png)

[Demo Activity](https://github.com/detmir/recycli/blob/master/app/src/main/java/com/detmir/kkppt3/Case0400IntoView.kt)


<a name="horizontal"/>

## Horizontal sub lists

It's common to have horizontal scrollig lists inside vertical scrolling container and recycli supports this feature. 
Firstly create container state and view for horizontal list. This is just another list of items, recycler with horizontal layout manager and adapter:

```java
@RecyclerItemState
data class SimpleContainerItem(
    val id: String,
    val recyclerState: List<RecyclerItem>
): RecyclerItem {
    override fun provideId(): String {
        return id
    }
}
```

```java
@RecyclerItemView
class SimpleContainerItemView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : FrameLayout(context, attrs, defStyleAttr) {
    private val recycler: RecyclerView
    private val recyclerAdapter: RecyclerAdapter

    init {
        val view =
            LayoutInflater.from(context).inflate(R.layout.simple_recycler_conteiner_view, this, true)
        layoutParams = ViewGroup.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
        )

        recyclerAdapter = RecyclerAdapter()
        recycler = view.findViewById(R.id.simple_recycler_container_recycler)

        recycler.run {
            isNestedScrollingEnabled = false
            layoutManager = LinearLayoutManager(context, RecyclerView.HORIZONTAL, false)
            adapter = recyclerAdapter
        }
    }

    @RecyclerItemStateBinder
    fun bindState(state: SimpleContainerItem) {
        recyclerAdapter.bindState(state.recyclerState)
    }
}
```

Now populate recycler items and sub list items as ususual

```java
class Case0500Horizontal : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        recyclerAdapter.bindState(
            listOf(
                HeaderItem(
                    id = "HEADER_SUB_TASKS",
                    title = "Subtasks"
                ),
                SimpleContainerItem(
                    id = "SUB_TASKS_CONTAINER",
                    recyclerState = (0..100).map {
                        SubTaskItem(
                            id = "SUB_TASK_$it",
                            title = "Sub task $it",
                            description = "It is a long established ..."
                        )
                    }
                ),
                BigTaskItem(
                    id = "TASK",
                    title = "The second task title",
                    description = "It is a long established ..."
                )
            )
        )
    }
}
```

![ezgif-2-9cf09cc92026](https://user-images.githubusercontent.com/1109620/115970440-0500c980-a54b-11eb-857f-9c955b7cb371.gif)

[Demo Activity](https://github.com/detmir/recycli/blob/master/app/src/main/java/com/detmir/kkppt3/Case0500Horizontal.kt)


<a name="multi_module"/>

## Multi-module applications

In case of your app has several modules and your recycler item states and views are located in different modules you still can combine them in one list. Each modulte has its own RecyclerBinderImpl generated by Recycli lib. Just pass all the needed binders to RecyclerAdapter adapter. 

```java
private var recyclerAdapter = RecyclerAdapter(
        binders = setOf(com.detmir.kkppt3.RecyclerBinderImpl(), com.detmir.ui.RecyclerBinderImpl()),
        infinityCallbacks = this,
        bottomLoading = BottomLoading()
    )
```
[Demo Activity](https://github.com/detmir/recycli/blob/master/app/src/main/java/com/detmir/kkppt3/Case0600Infinity.kt)

<a name="license"/>

## License

```
Copyright 2021 Detsky Mir Group

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```
